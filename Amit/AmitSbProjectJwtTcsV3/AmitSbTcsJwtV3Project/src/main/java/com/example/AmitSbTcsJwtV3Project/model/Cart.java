package com.example.AmitSbTcsJwtV3Project.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;

import java.util.List;

@Entity
public class Cart {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer cartId;//not int but integer
    //Auto means id is generated automatically based on type og primary key.. if numeric primary key then genearion
    //is based on strategy or table if uuid then uuid generator
    //Identity meansd this expects value generated by an identity column in database. they ars auto incremented
    //Sequence: hibernate creates new hibernate_sequence for generating id
    //Table means at table level

    private Double totalAmount;//NOT double but Double

    @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.REMOVE)
    @JsonIgnore
    private User user;
    // user_user_id in cart table by default if want can change name using join column, pk of the table as fk here
    //do you want userid in cart or cartid in user, if do not write mapped by here then
    // foreign key userid will be here in cart
    //if write mapped by then do not create foreign key there as already told that mapped by
    //which attribute only
    //where forgn key present that is child,

    //means when write mapped by then no fk there means that is parent
    //here cart is chil and user is parent

    //there are two things in Mapping, fetchType and Cascade, onemore is updatable = false
    //by default fetch type= lazy. if want to fetch userdetail immediately from db when fetching cart details

    //we will be needing userdetails when fetching cart so fetch eager

    //in gfg 3 types of cascade, all flows from parent to child only
    //on delete, on update, on insert :
    //on delte if cascade wrt toparent:  deleting from parent, delete from all childs,
    // if try to cascade wrt to child means if row from child
    //deleted then delete from parent the we will have to delete all the children of parent
    //on update, we update primary key in parent then all children fk must be updated
    //on insert: if inserting in parent then can make inserts in all childs

    //in hibernate, on save also.. if saving parent save children also

    //cascade in hibernate gfg:
    //When CascadeType.ALL is used, and any operation performed on the parent entity will be automatically propagated
    // to all child entities. This means that if you persist, update, or delete a parent entity, all child entities
    // associated with it will also be persisted, updated, or deleted accordingly.
    //@OneToMany(mappedBy="customer", cascade=CascadeType.ALL)

    //CascadeType.PERSIST is a cascading type in Hibernate that specifies that the create (or persist) operation
    // should be cascaded from the parent entity to the child entities.
    //When CascadeType.PERSIST is used, any new child entities associated with a parent entity will be automatically
    // persisted when the parent entity is persisted. However, updates or deletions made to the parent entity will
    // not be cascaded to the child entities.
    //@OneToMany(mappedBy="customer", cascade=CascadeType.PERSIST)

    //CascadeType.MERGE is a cascading type in Hibernate that specifies that the update (or merge) operation should be
    // cascaded from the parent entity to the child entities.
    //When CascadeType.MERGE is used, any changes made to a detached parent entity (i.e., an entity that is not
    // currently managed by the persistence context) will be automatically merged with its associated child
    // entities when the parent entity is merged back into the persistence context. However, new child entities
    // that are not already associated with the parent entity will not be automatically persisted.
    //@OneToMany(mappedBy="customer", cascade=CascadeType.MERGE)

    //CascadeType.REMOVE is a cascading type in Hibernate that specifies that the delete operation should
    // be cascaded from the parent entity to the child entities.
    //When CascadeType.REMOVE is used, any child entities associated with a parent entity will be automatically
    // deleted when the parent entity is deleted. However, updates or modifications made to the parent entity
    // will not be cascaded to the child entities.
    //@OneToMany(mappedBy="customer", cascade=CascadeType.REMOVE)

    //CascadeType.SAVE_UPDATE is a cascading type in Hibernate that specifies that the save or update
    // operation should be cascaded from the parent entity to the child entities.
    //When CascadeType.SAVE_UPDATE is used, any child entities associated with a parent entity will be
    // automatically saved or updated when the parent entity is saved or updated. This means that any changes made
    // to the child entities will be persisted in the database along with the parent entity.
    //@OneToMany(mappedBy="customer", cascade=CascadeType.SAVE_UPDATE)

    //CascadeType.REPLICATE
    //CascadeType.DETACH
    //CascadeType.REFRESH

    //Baeldung:
    //CascadeType.ALL propagates all operations — including Hibernate-specific ones — from a parent to a child entity.
    //Cascade Type PERSIST propagates the persist operation from a parent to a child entity. When we save the person
    // entity, the address entity will also get saved.
    //CascadeType.REMOVE propagates the remove operation from parent to child entity. Similar to JPA’s
    // CascadeType.REMOVE, we have CascadeType.DELETE, which is specific to Hibernate. There is no difference
    // between the two.
    //CascadeType.SAVE_UPDATE propagates the same operation to the associated child entity. It’s useful when we
    // use Hibernate-specific operations like save, update and saveOrUpdate.

    //same is done by durgesh also, jaha mapped by wahi cascade likha hai.. parengt me
    //repo.save bhi wahi likjte hain jaha cascade likha hai means parent me then child khud hi saved

    //in ManyToMany, bina join table ke bhi working, new table khud hi created, jaise joincolmn nhi likhte jab ek
    //hi column pk hoti as fk, same here join table needed when want to change names of new table and columns
    // mapped by jaha likha hai phle wahi likha th cascade
    //but baad me doosri class me likh diya.. and called repo.save yahi
    //but yaha fk kisi clas me nhi bnti balki ek separate table khud hi created for fks

    //but here written cascade in child class.. to aisa hai kya ki
    //jaha likhte hain means waha kuch kiya to same operation har jagah ho jayega automatically
    //agar child me likha remove to means agar child delete kiya to parent se bhi hoga and then uske sare child se
    //bhi hoga majboori me..  matlab ek child delete kiya to har jagah se child and parent delete

    //also problem here is ki inhone user class me Cart nhi likha.. means unidirectional relationship created

    //java guide: cascade one to one unidirectional in hibernate
    //The @OneToOne annotation is used to specify a one-to-one relationship between the Order entity and the
    // Address entity. The cascade attribute is set to CascadeType.ALL, which means that any changes made to the
    // Order entity will be propagated to the associated Address entity.
    //address is inside Order class so any change made to order entity will propagate to address entity

    //here written one to one in order only, so fk ctreated here only but still any changes to order will propagate to
    //other table address..
    //so nothing like parent child in unidirection.. bas jaha unidirectional likha hai usme koi change kiya to wo
    //related table me propagate hoga.. dlete save sab kuch for cascade all

    // order.setBillingAddress(billingAddress);
    //        // save both order and address ( Cascade type - ALL)
    //        orderRepository.save(order); --- PERSIST

    //The CascadeType.REMOVE is also inherited from the CascadeType.ALL configuration, so the Order entity
    // deletion triggers an Address entity removal too:
    //        // remove order with it's address
    //        orderRepository.deleteById(1L); --REMOVE

    //The CascadeType.MERGE is inherited from the CascadeType.ALL setting, so we only have to merge the Order entity,
    // and the associated Address is merged as well:
    // // fetch order with it's address
    //        Order order1 = orderRepository.findById(1L).get();
    //        order1.setStatus("DELIVERED");
    //        order1.getBillingAddress().setZipCode("11047");
    //        // update order along with that address
    //        orderRepository.save(order1);


    //bas simple sa hai jaha cascade wali line likhte hain, to uss entity me kuch bhi kiya to
    // same change doosri entity me bhi propagate hoga automatically..


    @OneToMany(fetch = FetchType.EAGER, mappedBy = "cart")
    private List<CartProduct> cartProduct;
    //cascade should be here, when delete cart, delete cart products also, save update
    //if relation is OneToMany.. if anywhere there is Many then we use List for that
    //One Cart contains Many CartProducts.. so use List here for CartProducts
    //as when we will show cart details we will have to show all the cart products not just one cart product

    //when fetching cart, fetch cartproducts also imeediately
    //mapped by means do not create fk here in this cart class, create in other class
    //means this is parent class.
    //waise to jaha mapped by likhte hain, cascade bhi wahi likhte hain
    //but here not written  here as when doing any changes to cart, same changes should be in all Cart Products

    public void updateTotalAmount(Double price){
        this.totalAmount += price;
    }
    //why is this method here

    public Integer getCartId() {
        return cartId;
    }

    public void setCartId(Integer cartId) {
        this.cartId = cartId;
    }

    public Double getTotalAmount() {
        return totalAmount;
    }

    public void setTotalAmount(Double totalAmount) {
        this.totalAmount = totalAmount;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List<CartProduct> getCartProduct() {
        return cartProduct;
    }

    public void setCartProduct(List<CartProduct> cartProduct) {
        this.cartProduct = cartProduct;
    }

    public Cart(Integer cartId, Double totalAmount, User user, List<CartProduct> cartProduct) {
        this.cartId = cartId;
        this.totalAmount = totalAmount;
        this.user = user;
        this.cartProduct = cartProduct;
    }

    public Cart() {
    }
}
